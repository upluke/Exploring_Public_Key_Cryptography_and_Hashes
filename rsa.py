from Crypto.Util import number

# https://en.wikipedia.org/wiki/RSA_(cryptosystem)   Key generation
# 
# 
# 
# ℤ^* n = {0<=integer<n}
# p, q are secrets from Alice
# d = ALice's private key
# e, n = public key
# lambda_n is also private but calculated by p and q
def rsa(M_bob: bytes = b"hello from Bob"):    # M is sent by Bob
    e = 65537
    num_bits = 2048
    p = number.getPrime(num_bits) # gerate a prime num
    q = number.getPrime(num_bits)
    n = p*q
    lambda_n = lcm(p-1, q-1)
    _, x, _ = extended_gcd(e, lambda_n) # we know gcd is 1, and ond't care about y
    # solving for d:
    # e * x  ≡ 1(mod lambda_n)
    # d  ≡ e^-1 mod lambda_n 
    # e * d  ≡ 1 mod lambda_n
    # x  ≡ d
    # x =  d (% lambda_n)
    # d  = x (% lambda_n)        
    
    # a≡b(mod m) <=> a%m = b%m 
    # we want to get 0<= d < lamdba_n
    d = x%lambda_n
    
    # Bob:
    # Encrypt and decrypt a few messages to yourself to make sure it works. Remember messages must be integers in ℤ*n. You can convert an ASCII string to hex, and then turn that hex value into an integer.
    # Encryption: convert an ASCII string to hex, and then turn that hex value into an integer.
    m_bob=   int.from_bytes(M_bob, "big")  # <=>  int(M_bob.hex(), 16)
    # c≡m^e (mod n)        e and n compose Alice public ke 
    c = pow(m_bob, e, n) 
    
    # Alice:
    # Decryption: 
    # c^d ≡(m^e)^d ≡ m(mod n)
    m_alice = pow(c, d, n)   # m_alice is integer rn
    size = -(-n.bit_length()//8) # need to know how many bytess maximum can be used to fit the msg, becaus 0<= m<n       // -(-n shourtcut for ceiling division
    M_alice = m_alice.to_bytes(size, "big").strip(b'\0') # strip off "\0\0\0" caused by the fact m < n
    print("Alice received: ", M_alice)
    
    
    
    
def lcm(a: int, b: int):
    return abs(a*b)//gcd(a,b)

def gcd(a: int, b: int):
    while b !=0:
        a, b = b, a%b
    return a


# >>> extended_gcd(3, 7)
# (1, -2, 1)
# 3* -2 + 7*1 = 1
# a * x +b * y = gcd(a, b)
def extended_gcd(a: int,  b: int):  
    x, y, u, v = 0, 1, 1, 0

    while a != 0:
        q, r = divmod(b, a)
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n

    gcd = b
    return gcd, x, y
    

if __name__ == "__main__":
     
    rsa()
    
    
    
# While it’s very common for many people to share an e (common values are 3,7, 216+1), it is very bad if two people share an RSA modulus n. Briefly describe why this is, and what the ramifications are.
# n=pq     pq are big primes , if everyone knows n,and they know p and q, since n is generated by pg, they can use lambd_n to crack for d
